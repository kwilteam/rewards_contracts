package signer

import (
	"context"
	"crypto/ecdsa"
	"encoding/hex"
	"fmt"
	"testing"

	"github.com/ethereum/go-ethereum/crypto"
	"github.com/kwilteam/kwil-db/core/client"
	clientTypes "github.com/kwilteam/kwil-db/core/client/types"
	crypto2 "github.com/kwilteam/kwil-db/core/crypto"
	"github.com/kwilteam/kwil-db/core/crypto/auth"
	"github.com/spf13/pflag"
	"github.com/stretchr/testify/require"
)

var testPK = pflag.String("pk", "59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d", "eth private key")

func getTestSignerOpts(t *testing.T) *clientTypes.Options {
	t.Helper()

	pkBytes, err := hex.DecodeString(*testPK)
	require.NoError(t, err)

	key, err := crypto2.UnmarshalSecp256k1PrivateKey(pkBytes)
	require.NoError(t, err)

	opts := clientTypes.Options{Signer: &auth.EthPersonalSigner{Key: *key}}

	return &opts
}

func getTestPK(t *testing.T) *ecdsa.PrivateKey {
	t.Helper()

	privateKey, err := crypto.HexToECDSA(*testPK)
	require.NoError(t, err)

	return privateKey
}

func Test_issue_reward(t *testing.T) {
	ctx := context.Background()
	opts := getTestSignerOpts(t)

	clt, err := client.NewClient(ctx, "http://localhost:8484", opts)
	require.NoError(t, err)

	procedure := "issue_reward"

	res, err := clt.Execute(ctx, "mydb", procedure, nil)
	require.NoError(t, err)

	fmt.Printf("issue_reward================%+v\n", res.String())
}

func Test_kwilApi_FetchPendingRewards(t *testing.T) {
	ctx := context.Background()

	clt, err := client.NewClient(ctx, "http://localhost:8484", nil)
	require.NoError(t, err)

	k := NewKwilApi(clt, "y_rewards")

	got, err := k.FetchPendingRewards(ctx, 0, 10000)
	require.NoError(t, err)

	for _, r := range got {
		fmt.Println(r)
	}
}

func Test_kwilApi_FetchEpochRewards(t *testing.T) {
	ctx := context.Background()

	clt, err := client.NewClient(ctx, "http://localhost:8484", nil)
	require.NoError(t, err)

	k := NewKwilApi(clt, "y_rewards")

	got, err := k.FetchEpochRewards(ctx, 0, 10)
	require.NoError(t, err)

	for _, r := range got {
		fmt.Println(r)
	}
}

func Test_kwilApi_FetchLatestFinalizedReward(t *testing.T) {
	ctx := context.Background()

	clt, err := client.NewClient(ctx, "http://localhost:8484", nil)
	require.NoError(t, err)

	k := NewKwilApi(clt, "y_rewards")

	got, err := k.FetchLatestRewards(ctx, 10)
	require.NoError(t, err)

	for _, r := range got {
		fmt.Println(r)
	}
}

func Test_kwilApi_ProposeEpoch(t *testing.T) {
	ctx := context.Background()
	opts := getTestSignerOpts(t)
	clt, err := client.NewClient(ctx, "http://localhost:8484", opts)
	require.NoError(t, err)

	k := NewKwilApi(clt, "y_rewards")

	h, err := k.ProposeEpoch(ctx)
	require.NoError(t, err)

	fmt.Println(h)
}

func Test_kwilApi_VoteEpoch(t *testing.T) {
	ctx := context.Background()
	opts := getTestSignerOpts(t)
	pk := getTestPK(t)

	clt, err := client.NewClient(ctx, "http://localhost:8484", opts)
	require.NoError(t, err)

	k := NewKwilApi(clt, "y_rewards")

	signHashHex := "dd4bf09c5800ab9bd8a461955f33a13970c1dffd0f57e0063c7da5e982cdb9a0"
	signHash, err := hex.DecodeString(signHashHex)
	require.NoError(t, err)

	sig, err := EthGnosisSignDigest(signHash, pk)
	require.NoError(t, err)

	fmt.Printf("Yaiba.vote.batch.input--------digest:%x, sig:%x\n", signHash, sig)

	//EthGnosisVerify(sig)

	h, err := k.VoteEpoch(ctx, signHash, sig)
	require.NoError(t, err)

	fmt.Println(h)

	//         	            	 (sql) syntax error: extraneous input '{' expecting {',', 'delete', 'update', 'select', 'insert'}
	//        	            	 start 3:85 end 4:1
	//        	            	 (sql) syntax error: missing '[' at '('
	//        	            	 start 5:80 end 5:85
	//        	            	 (sql) syntax error: missing ']' at ')'
	//        	            	 start 5:156 end 5:163
	//        	            	jsonrpc.Error: code = -201, message = broadcast error, data = {
	//        	            	  "tx_code": 65535,
	//        	            	  "hash": "be212875e73e835eb6e2d2a34e3b64f4ed8fb1853ab993964084a100ef950295",
	//        	            	  "message": "parse error: detected multiple parse errors:\n (sql) syntax error: extraneous input '{' expecting {',', 'delete', 'update', 'select', 'insert'}\n start 3:85 end 4:1\n (sql) syntax error: missing '[' at '('\n start 5:80 end 5:85\n (sql) syntax error: missing ']' at ')'\n start 5:156 end 5:163"
	//        	            	}
	//        	            	err code = -201, msg = broadcast error
}

func Test_dddd(t *testing.T) {
	a := []uint8{0xcf, 0xf0, 0xb0, 0xa9, 0x66, 0x97, 0x10, 0xf5, 0x1d, 0x72, 0x4e, 0xde, 0xf0, 0x3d, 0xf7, 0x6e, 0x79, 0xc2, 0x8e, 0x70, 0xe0, 0xe9, 0xee, 0xb, 0x36, 0x4d, 0xed, 0xba, 0xc3, 0xa2, 0xa6, 0x90}
	fmt.Println(hex.EncodeToString(a))

	b := []uint8{0xe5, 0x66, 0x8c, 0xfc, 0x69, 0xb8, 0x3, 0x56, 0x31, 0x69, 0xaf, 0xf2, 0x7d, 0x60, 0x66, 0x25, 0x92, 0xc1, 0xe5, 0xa7, 0xcc, 0x1c, 0x1f, 0xe2, 0xb6, 0x9d, 0x5f, 0x2a, 0xbc, 0xb2, 0x83, 0xe4}
	fmt.Println(hex.EncodeToString(b))

	c := []uint8{0x95, 0x13, 0xb2, 0x4b, 0xe7, 0x97, 0x95, 0x28, 0x68, 0xa4, 0xb0, 0xe4, 0x15, 0x84, 0xa4, 0x5a, 0xb3, 0x59, 0x67, 0xa6, 0x3, 0x38, 0xc5, 0xd5, 0xe9, 0x8c, 0xc1, 0x47, 0xcb, 0x2, 0xd9, 0x9}
	fmt.Println(hex.EncodeToString(c))

	d := []uint8{0x7b, 0x22, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x2d, 0x76, 0x31, 0x22, 0x2c, 0x22, 0x74, 0x72, 0x65, 0x65, 0x22, 0x3a, 0x5b, 0x22, 0x30, 0x78, 0x38, 0x30, 0x64, 0x30, 0x36, 0x36, 0x38, 0x31, 0x37, 0x66, 0x33, 0x63, 0x39, 0x33, 0x61, 0x34, 0x63, 0x35, 0x32, 0x30, 0x32, 0x32, 0x36, 0x30, 0x32, 0x65, 0x35, 0x64, 0x39, 0x33, 0x34, 0x64, 0x66, 0x32, 0x38, 0x37, 0x32, 0x32, 0x30, 0x30, 0x36, 0x38, 0x66, 0x32, 0x65, 0x37, 0x30, 0x61, 0x32, 0x32, 0x38, 0x63, 0x61, 0x34, 0x66, 0x38, 0x39, 0x61, 0x63, 0x37, 0x36, 0x65, 0x61, 0x39, 0x22, 0x5d, 0x2c, 0x22, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x22, 0x3a, 0x5b, 0x7b, 0x22, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x3a, 0x5b, 0x22, 0x30, 0x78, 0x37, 0x30, 0x39, 0x39, 0x37, 0x39, 0x37, 0x30, 0x43, 0x35, 0x31, 0x38, 0x31, 0x32, 0x64, 0x63, 0x33, 0x41, 0x30, 0x31, 0x30, 0x43, 0x37, 0x64, 0x30, 0x31, 0x62, 0x35, 0x30, 0x65, 0x30, 0x64, 0x31, 0x37, 0x64, 0x63, 0x37, 0x39, 0x43, 0x38, 0x22, 0x2c, 0x22, 0x32, 0x32, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x22, 0x2c, 0x22, 0x30, 0x78, 0x35, 0x35, 0x45, 0x41, 0x43, 0x36, 0x36, 0x32, 0x43, 0x39, 0x44, 0x37, 0x37, 0x63, 0x62, 0x35, 0x33, 0x37, 0x44, 0x42, 0x63, 0x39, 0x41, 0x35, 0x37, 0x43, 0x30, 0x61, 0x44, 0x61, 0x39, 0x30, 0x65, 0x42, 0x38, 0x38, 0x31, 0x33, 0x32, 0x64, 0x22, 0x2c, 0x22, 0x32, 0x37, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x72, 0x65, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x22, 0x3a, 0x30, 0x7d, 0x5d, 0x2c, 0x22, 0x6c, 0x65, 0x61, 0x66, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x22, 0x3a, 0x5b, 0x22, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x2c, 0x22, 0x75, 0x69, 0x6e, 0x74, 0x32, 0x35, 0x36, 0x22, 0x2c, 0x22, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x2c, 0x22, 0x75, 0x69, 0x6e, 0x74, 0x32, 0x35, 0x36, 0x22, 0x5d, 0x7d}
	fmt.Println(hex.EncodeToString(d))
	dd, err := hex.DecodeString(hex.EncodeToString(d))
	fmt.Println(string(dd))
	fmt.Println(err)
}
